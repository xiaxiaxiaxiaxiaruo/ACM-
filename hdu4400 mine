#include<iostream>
#include<cstdio>
#include<vector>
#include<set>
#include<map>
#include<algorithm>
#include<cstring>
#include<queue>

using namespace std;

const int N=100000+5;

struct Mine{
	int x,y,d;
	int id;
	Mine(){
	};
	Mine(int x,int y,int d,int id):x(x),y(y),d(d),id(id){
	};
}mines[N];

struct node{
	int y;
	int d;
	int id;
	node(){
	};
	node(int y):y(y){
	};
	node(int y,int d,int id):y(y),d(d),id(id){
	};
	friend bool operator < (node a,node b){
		return a.y<b.y;
	};

};
bool exist[N];
int n,m;
map<int,int>mpx;
vector<int>xi;
multiset<node> s[N];
void init(){
	memset(exist,true,sizeof exist);
	xi.clear();
	for(int i=0;i<=n;++i)
	mpx.clear();
	
}

void work(int id){
	queue<node> q;
	map<int,int>::iterator it;

	q.push(node(mines[id].y,mines[id].d,mines[id].id));
	int ans=0;

	int l,r,dy;
	multiset<node>::iterator jup,jlow,j;

	while(!q.empty()){
	
		node tmp=q.front();q.pop();
		if(exist[tmp.id]){
			ans++;
			exist[tmp.id]=false;
			l=mines[tmp.id].x-tmp.d,r=mines[tmp.id].x+tmp.d;
			//
			l=l<0?1:l;
			cout<<l<<" lr "<<r<<endl;
			if(r>xi.size()){
				r=xi.size();
			}
			for(int i=l;i<=r;i++){
				it=mpx.find(i);
				dy=mines[tmp.id].d-it->first;
				//
				cout<<it->first<<" "<<it->second<<endl;
				jlow=s[i].lower_bound(tmp.y-dy);
				jup=s[i].lower_bound(tmp.y+dy);
				for(j=jlow;j!=jup;j++){
					q.push(*j);
				}	
				s[i].erase(jlow,jup);
			}
		}
	}
	printf("%d\n",ans);
}
int main(){
	int a,b,c;
	while(cin>>n,n){
		init();
		for(int i=1;i<=n;i++){
			scanf("%d%d%d",&a,&b,&c);
			mines[i]=Mine(a,b,c,i);
			xi.push_back(a);
		}
		sort(xi.begin(),xi.end());
		xi.erase(unique(xi.begin(),xi.end()),xi.end());
		int cnt=0;
		for(int i=0;i<xi.size();i++){
			mpx[xi[i]]=++cnt;
		}
		map<int,int>::iterator it;
		for(it=mpx.begin();it!=mpx.end();++it){
			cout<<it->first<<" "<<it->second<<endl;
		}
		for(int i=1;i<=n;i++){
			int p=mpx[mines[i].x];
			s[p].insert(node(mines[i].y,mines[i].d,mines[i].id));
		}
		cin>>m;
		
		for(int i=1;i<=m;i++){
			scanf("%d",&a);
			work(a);
		}
		
		
	}
	return 0;
}
